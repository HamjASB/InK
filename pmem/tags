!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARRAY_CHILDREN	btree.h	7;"	d
ARRAY_NODE	btree.h	6;"	d
BTREE_H_	btree.h	2;"	d
BTree	btree.h	/^struct BTree {$/;"	s
BTreeNode	btree.h	/^struct BTreeNode {$/;"	s
BTreeNode_create	btree.c	/^struct BTreeNode *BTreeNode_create() {$/;"	f
BTreeNode_list	btree.c	/^static struct free_list *BTreeNode_list;$/;"	v	typeref:struct:free_list	file:
BTreeNode_splitnormal	btree.c	/^struct BTreeNode *BTreeNode_splitnormal(char *input_key, struct BTreeNode *input_parentNode) {$/;"	f
BTreeNode_splitroot	btree.c	/^struct BTreeNode *BTreeNode_splitroot(struct BTreeNode *input_parentNode) {$/;"	f
BTree_insert	btree.c	/^int BTree_insert(struct KeyValue *input_kv) {$/;"	f
BTree_remove	btree.c	/^int BTree_remove(char *key) {$/;"	f
BTree_search	btree.c	/^int BTree_search(char *key) {$/;"	f
INFO_H_	info.h	2;"	d
KeyValue	btree.h	/^struct KeyValue {$/;"	s
KeyValue_create	btree.c	/^struct KeyValue *KeyValue_create(char *key_offset, char *value_offset) {$/;"	f
KeyValue_duplicate	btree.c	/^struct KeyValue *KeyValue_duplicate(struct KeyValue *input_kv) {$/;"	f
KeyValue_list	btree.c	/^static struct free_list *KeyValue_list;$/;"	v	typeref:struct:free_list	file:
PMEM_CAP	btree.h	10;"	d
TEST_H_	test.h	2;"	d
addValue	btree.c	/^void addValue(struct BTreeNode *input_node, struct KeyValue *input_kv, struct BTreeNode *input_left, struct BTreeNode *input_right){$/;"	f
children	btree.h	/^        struct BTreeNode *children[ARRAY_CHILDREN]; \/\/array of pointers of children$/;"	m	struct:BTreeNode	typeref:struct:BTreeNode::BTreeNode
chunks	btree.h	/^        struct KeyValue *chunks[ARRAY_NODE]; \/\/array of pointers of chunks$/;"	m	struct:BTreeNode	typeref:struct:BTreeNode::KeyValue
clearKV	btree.c	/^void clearKV(struct KeyValue *input_kv) {$/;"	f
clearNode	btree.c	/^void clearNode(struct BTreeNode *input_node) {$/;"	f
data_arr	btree.c	/^static struct free_list *data_arr;$/;"	v	typeref:struct:free_list	file:
findValue	btree.c	/^int findValue(struct BTreeNode *input_node, char *input_key) {$/;"	f
findValue_search	btree.c	/^int findValue_search(struct BTreeNode *input_node, char *input_key) {$/;"	f
free_list	btree.h	/^struct free_list {$/;"	s
free_node	btree.h	/^struct free_node {$/;"	s
head	btree.h	/^				struct free_node *head;$/;"	m	struct:free_list	typeref:struct:free_list::free_node
insertTest	test.c	/^void insertTest(void *pmem) {$/;"	f
key	btree.h	/^        char *key; \/\/key, 256 byte$/;"	m	struct:KeyValue
level	btree.h	/^        int level;$/;"	m	struct:BTree
main	pmem.c	/^int main() {$/;"	f
meta	btree.c	/^static void **meta;$/;"	v	file:
next	btree.h	/^				struct free_node *next;$/;"	m	struct:free_node	typeref:struct:free_node::free_node
nextNodeIndex	btree.c	/^int nextNodeIndex (struct BTreeNode *input_node, char *input_key) {$/;"	f
nextNodeIndex_search	btree.c	/^int nextNodeIndex_search (struct BTreeNode *input_node, char *input_key) {$/;"	f
next_string	btree.c	/^static char *next_string;$/;"	v	file:
next_struct	btree.c	/^static void *next_struct;$/;"	v	file:
nr_chunks	btree.h	/^        int nr_chunks; \/\/current number of chunks, MAX ARRAY_NODE$/;"	m	struct:BTreeNode
nr_node	btree.h	/^				int nr_node;$/;"	m	struct:free_list
pmem	btree.c	/^static void *pmem;$/;"	v	file:
pmem_exit	btree.c	/^int pmem_exit() {$/;"	f
pmem_init	btree.c	/^long long unsigned int pmem_init() {$/;"	f
pmem_load	btree.c	/^long long unsigned int pmem_load() {$/;"	f
realloc_BTreeNode	btree.c	/^struct BTreeNode *realloc_BTreeNode() {$/;"	f
realloc_KeyValue	btree.c	/^struct KeyValue *realloc_KeyValue() {$/;"	f
realloc_string	btree.c	/^char *realloc_string(size_t length) {$/;"	f
recall_BTreeNode	btree.c	/^void recall_BTreeNode(struct BTreeNode *input_node) {$/;"	f
recall_KeyValue	btree.c	/^void recall_KeyValue(struct KeyValue *input_kv) {$/;"	f
recall_string	btree.c	/^void recall_string(char *input_string) {$/;"	f
removeTest	test.c	/^void removeTest() {$/;"	f
removeValue	btree.c	/^void removeValue(struct BTreeNode *input_node, int index) {$/;"	f
root	btree.c	/^static struct BTreeNode *root;$/;"	v	typeref:struct:BTreeNode	file:
root	btree.h	/^        struct BTreeNode *root; \/\/root node pointer.$/;"	m	struct:BTree	typeref:struct:BTree::BTreeNode
rwLock	test.c	/^pthread_rwlock_t rwLock;$/;"	v
searchTest	test.c	/^void searchTest() {$/;"	f
show_info	info.c	/^int show_info(void *pmem, void **meta, $/;"	f
swapValue	btree.c	/^char *swapValue(struct BTreeNode *input_willDelete, int index) {$/;"	f
tail	btree.h	/^				struct free_node *tail;$/;"	m	struct:free_list	typeref:struct:free_list::free_node
testLimit	test.c	/^int testLimit = 100000;$/;"	v
value	btree.h	/^        char *value; \/\/value, 4096 byte$/;"	m	struct:KeyValue
